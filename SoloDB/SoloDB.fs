namespace SoloDatabase

open SoloDatabase.JsonSerializator
open Microsoft.Data.Sqlite
open System.Linq.Expressions
open System
open System.Collections.Generic
open System.Collections
open SoloDatabase.Types
open System.IO
open System.Text
open SQLiteTools
open JsonFunctions
open FileStorage
open Connections
open Utils
open System.Runtime.CompilerServices
open System.Reflection
open System.Data
open System.Globalization
open System.Linq
open SoloDatabase.Attributes

/// <summary>
/// Contains internal helper functions for database and collection management.
/// </summary>
module internal Helper =
    /// <summary>
    /// Creates a disposable mutex for a given table name to ensure thread-safe operations on that table.
    /// </summary>
    /// <param name="connectionStr">The connection string, used to ensure the lock is specific to the database instance.</param>
    /// <param name="name">The name of the table to lock.</param>
    /// <returns>A disposable mutex object.</returns>
    let internal lockTable (connectionStr: string) (name: string) =
        let mutex = new DisposableMutex($"SoloDB-{StringComparer.InvariantCultureIgnoreCase.GetHashCode(connectionStr)}-Table-{name}")
        mutex

    /// <summary>
    /// Checks if a collection with the specified name exists in the database.
    /// </summary>
    /// <param name="name">The name of the collection.</param>
    /// <param name="connection">The active SQLite connection.</param>
    /// <returns>True if the collection exists, otherwise false.</returns>
    let internal existsCollection (name: string) (connection: SqliteConnection) =
        connection.QueryFirstOrDefault<string>("SELECT Name FROM SoloDBCollections WHERE Name = @name LIMIT 1", {|name = name|}) <> null

    /// <summary>
    /// Drops a collection's table and removes its metadata entry.
    /// </summary>
    /// <param name="name">The name of the collection to drop.</param>
    /// <param name="connection">The active SQLite connection.</param>
    let internal dropCollection (name: string) (connection: SqliteConnection) =
        connection.Execute(sprintf "DROP TABLE IF EXISTS \"%s\"" name) |> ignore
        connection.Execute("DELETE FROM SoloDBCollections Where Name = @name", {|name = name|}) |> ignore

    /// <summary>
    /// Inserts a JSON string into a specified table, with options for replacement and explicit ID.
    /// </summary>
    /// <param name="orReplace">If true, uses 'INSERT OR REPLACE'.</param>
    /// <param name="id">An optional ID to insert. If None, an ID is generated by SQLite.</param>
    /// <param name="name">The name of the target table (collection).</param>
    /// <param name="json">The JSON string to insert.</param>
    /// <param name="connection">The active SQLite connection.</param>
    /// <returns>The ID of the inserted row.</returns>
    let private insertJson (orReplace: bool) (id: int64 option) (name: string) (json: string) (connection: SqliteConnection) =
        let includeId = id.IsSome

        let queryStringBuilder = StringBuilder(64 + name.Length + (if orReplace then 11 else 0) + (if includeId then 7 else 0))

        let queryString =
            queryStringBuilder
                .Append("INSERT ")
                .Append(if orReplace then "OR REPLACE " else String.Empty)
                .Append(" INTO \"")
                .Append(name)
                .Append("\"(")
                .Append(if includeId then "Id," else String.Empty)
                .Append("Value) VALUES(")
                .Append(if includeId then "@id," else String.Empty)
                .Append("jsonb(@jsonText)) RETURNING Id;")
                .ToString()

        let parameters: obj = 
            if includeId then {|
                name = name
                jsonText = json
                id = id.Value
            |}
            else {|
                name = name
                jsonText = json
            |}


        connection.QueryFirst<int64>(queryString, parameters)

    /// <summary>
    /// Core implementation for inserting an item into a collection. Handles ID generation and serialization.
    /// </summary>
    /// <param name="typed">If true, serializes the object with its .NET type information.</param>
    /// <param name="item">The item to insert.</param>
    /// <param name="connection">The active SQLite connection.</param>
    /// <param name="name">The name of the collection.</param>
    /// <param name="orReplace">If true, performs an 'INSERT OR REPLACE' operation.</param>
    /// <param name="collection">The collection instance, used for ID generation context.</param>
    /// <returns>The ID of the inserted item.</returns>
    let private insertImpl<'T when 'T :> obj> (typed: bool) (item: 'T) (connection: SqliteConnection) (name: string) (orReplace: bool) (collection: ISoloDBCollection<'T>) =
        let customIdGen = CustomTypeId<'T>.Value
        let existsWritebleDirectId = HasTypeId<'T>.Value


        match customIdGen with
        | Some x ->
            let oldId = x.GetId item
            match x.Generator with
            | :? SoloDatabase.Attributes.IIdGenerator as generator ->
                if generator.IsEmpty oldId then
                    let id = generator.GenerateId collection item
                    x.SetId id item
            | :? SoloDatabase.Attributes.IIdGenerator<'T> as generator ->
                if generator.IsEmpty oldId then
                    let id = generator.GenerateId collection item
                    x.SetId id item
            | other -> raise (InvalidOperationException(sprintf "Invalid Id generator type: %s" (other.GetType().ToString())))
        | None -> ()
        
        let json = if typed then toTypedJson item else toJson item
        

        let id =
            if existsWritebleDirectId && -1L >= HasTypeId<'T>.Read item then 
                raise (InvalidOperationException "The Id must be either be:\n a) equal to 0, for it to be replaced by SQLite.\n b) A value greater than 0, for a specific Id to be inserted.")
            elif existsWritebleDirectId && 0L <> HasTypeId<'T>.Read item then 
                // Inserting with Id
                insertJson orReplace (Some (HasTypeId<'T>.Read item)) name json connection
            else
                // Inserting without Id
                insertJson orReplace None name json connection

        if existsWritebleDirectId then
            HasTypeId<'T>.Write item id

        id

    /// <summary>
    /// Inserts an item into a collection.
    /// </summary>
    let inline internal insertInner (typed: bool) (item: 'T) (connection: SqliteConnection) (name: string) (collection: ISoloDBCollection<'T>) =
        insertImpl typed item connection name false collection

    /// <summary>
    /// Inserts or replaces an item in a collection.
    /// </summary>
    let inline internal insertOrReplaceInner (typed: bool) (item: 'T) (connection: SqliteConnection) (name: string) (collection: ISoloDBCollection<'T>) =
        insertImpl typed item connection name true collection

    /// <summary>
    /// Sanitizes a collection name to prevent SQL injection and ensure it's a valid table name.
    /// </summary>
    /// <param name="name">The raw collection name.</param>
    /// <returns>A sanitized name containing only letters, digits, and underscores.</returns>
    let internal formatName (name: string) =
        String(name.ToCharArray() |> Array.filter(fun c -> Char.IsLetterOrDigit c || c = '_')) // Anti SQL injection

    /// <summary>
    /// Creates a Dictionary from a sequence of KeyValuePairs.
    /// </summary>
    let internal createDict(items: KeyValuePair<'a, 'b> seq) =
        let dic = new Dictionary<'a, 'b>()
        
        for kvp in items do
            dic.Add(kvp.Key, kvp.Value)

        dic

    /// <summary>
    /// Retrieves properties of a type that are marked with the [Indexed] attribute.
    /// </summary>
    /// <returns>An array of tuples, each containing the PropertyInfo and the IndexedAttribute instance.</returns>
    let internal getIndexesFields<'a>() =
        // Get all serializable properties
        typeof<'a>.GetProperties(BindingFlags.Public ||| BindingFlags.Instance)
        |> Array.choose(
            fun p -> // That have the IndexedAttribute
                match p.GetCustomAttribute<SoloDatabase.Attributes.IndexedAttribute>(true) with
                | a when isNull a -> None
                | a -> Some(p, a)) // With its uniqueness information.

    /// <summary>
    /// Translates a LINQ expression into an SQL index definition and a sanitized index name.
    /// </summary>
    /// <param name="name">The name of the collection.</param>
    /// <param name="expression">The LINQ expression defining the index key(s).</param>
    /// <returns>A tuple containing the generated index name and the SQL for the indexed columns.</returns>
    let internal getIndexWhereAndName<'T, 'R> (name: string) (expression: Expression<System.Func<'T, 'R>>) =
        if isNull expression then raise (ArgumentNullException(nameof(expression)))

        let whereSQL, variables = QueryTranslator.translate name expression
        let whereSQL = whereSQL.Replace($"\"{name}\".Value", "Value") // {name}.Value is not allowed in an index.
        if whereSQL.Contains $"\"{name}\".Id" then raise (ArgumentException "The Id of a collection is always stored in an index.") 
        if variables.Count > 0 then raise (ArgumentException "Cannot have variables in index.")
        let expressionBody = expression.Body

        if QueryTranslator.isAnyConstant expressionBody then raise(InvalidOperationException "Cannot index an outside or constant expression.")

        let whereSQL =
            match expressionBody with
            | :? NewExpression as ne when isTuple ne.Type
                -> whereSQL.Substring("json_array".Length)
            | :? MethodCallExpression
            | :? MemberExpression ->
                $"({whereSQL})"
            | other -> raise (ArgumentException (sprintf "Cannot index an expression with type: %s" (other.GetType().FullName)))

        let expressionStr = whereSQL.ToCharArray() |> Seq.filter(fun c -> Char.IsAsciiLetterOrDigit c || c = '_') |> Seq.map string |> String.concat ""
        let indexName = $"{name}_index_{expressionStr}"
        indexName, whereSQL

    /// <summary>
    /// Ensures a non-unique index exists for the given expression.
    /// </summary>
    let internal ensureIndex<'T, 'R> (collectionName: string) (conn: SqliteConnection) (expression: Expression<System.Func<'T, 'R>>) =
        let indexName, whereSQL = getIndexWhereAndName<'T,'R> collectionName expression

        let indexSQL = $"CREATE INDEX IF NOT EXISTS {indexName} ON \"{collectionName}\"{whereSQL}"

        conn.Execute(indexSQL)

    /// <summary>
    /// Ensures a unique index exists for the given expression.
    /// </summary>
    let internal ensureUniqueAndIndex<'T,'R> (collectionName: string) (conn: SqliteConnection) (expression: Expression<System.Func<'T, 'R>>) =
        let indexName, whereSQL = getIndexWhereAndName<'T,'R> collectionName expression

        let indexSQL = $"CREATE UNIQUE INDEX IF NOT EXISTS {indexName} ON \"{collectionName}\"{whereSQL}"

        conn.Execute(indexSQL)

    /// <summary>
    /// Ensures that all indexes declared via the [Indexed] attribute on the type 'T exist.
    /// </summary>
    let internal ensureDeclaredIndexesFields<'T> (name: string) (conn: SqliteConnection) =
        for (pi, indexed) in getIndexesFields<'T>() do
            let ensureIndexesFn = if indexed.Unique then ensureUniqueAndIndex else ensureIndex
            let _code = ensureIndexesFn name conn (ExpressionHelper.get<obj, obj>(fun row -> row.Dyn<obj>(pi.Name)))
            ()

    /// <summary>
    /// Creates a new table for a collection, including its metadata entry and declared indexes.
    /// </summary>
    let internal createTableInner<'T> (name: string) (conn: SqliteConnection) =
        conn.Execute($"CREATE TABLE \"{name}\" (
                        Id INTEGER NOT NULL PRIMARY KEY UNIQUE,
                        Value JSONB NOT NULL
                    );", {|name = name|}) |> ignore
        conn.Execute("INSERT INTO SoloDBCollections(Name) VALUES (@name)", {|name = name|}) |> ignore

        // Ignore the untyped collections.
        if not (typeof<JsonSerializator.JsonValue>.IsAssignableFrom typeof<'T>) then
            ensureDeclaredIndexesFields<'T> name conn

    /// <summary>
    /// Internal DTO to pass data from the main DB instance to collection instances.
    /// </summary>
    let internal collectionNameOf<'T> =
        typeof<'T>.Name |> formatName

type internal SoloDBToCollectionData = {
    /// <summary>
    /// A function that, when called, clears the database connection cache.
    /// </summary>
    ClearCacheFunction: unit -> unit
}

/// <summary>
/// Represents a collection of documents of type 'T stored in the database. Provides methods for CRUD operations, indexing, and LINQ querying.
/// </summary>
/// <param name="connection">The connection provider.</param>
/// <param name="name">The name of the collection (table name).</param>
/// <param name="connectionString">The database connection string.</param>
/// <param name="parentData">Data from the parent SoloDB instance.</param>
type internal Collection<'T>(connection: Connection, name: string, connectionString: string, parentData: SoloDBToCollectionData) as this =
    member val private SoloDBQueryable = SoloDBCollectionQueryable<'T, 'T>(SoloDBCollectionQueryProvider(this, parentData), Expression.Constant(RootQueryable<'T>(this))) :> IOrderedQueryable<'T>
    member val private ConnectionString = connectionString
    /// <summary>Gets the name of the collection.</summary>
    member val Name = name
    /// <summary>Gets a value indicating whether the collection is operating within a transaction.</summary>
    member val InTransaction = match connection with | Transactional _ | Transitive _ -> true | Pooled _ -> false
    /// <summary>Gets a value indicating whether type information should be included during serialization for documents in this collection.</summary>
    member val IncludeType = mustIncludeTypeInformationInSerialization<'T>
    /// <summary>Gets the internal connection provider for this collection.</summary>
    member val internal Connection = connection

    /// <summary>
    /// Inserts a new document into the collection.
    /// </summary>
    /// <param name="item">The document to insert.</param>
    /// <returns>The ID of the newly inserted document.</returns>
    member this.Insert (item: 'T) =
        use connection = connection.Get()
        Helper.insertInner this.IncludeType item connection name this

    /// <summary>
    /// Inserts a new document or replaces an existing one if a document with the same ID already exists.
    /// </summary>
    /// <param name="item">The document to insert or replace.</param>
    /// <returns>The ID of the inserted or replaced document.</returns>
    member this.InsertOrReplace (item: 'T) =
        use connection = connection.Get()
        Helper.insertOrReplaceInner this.IncludeType item connection name this

    /// <summary>
    /// Inserts a sequence of documents in a single transaction for efficiency.
    /// </summary>
    /// <param name="items">The sequence of documents to insert.</param>
    /// <returns>A list of IDs for the newly inserted documents.</returns>
    member this.InsertBatch (items: 'T seq) =
        if isNull items then raise (ArgumentNullException(nameof(items)))

        if this.InTransaction then
            use connection = connection.Get()

            let ids = List<int64>()
            for item in items do
                Helper.insertInner this.IncludeType item connection name this |> ids.Add
            ids
        else

        use connection = connection.Get()
        use _disabled = (unbox<IDisableDispose> connection).DisableDispose()
        let directConnection = Transitive connection
        let transientConnection = Collection(directConnection, name, connectionString, parentData)
        connection.Execute "BEGIN;" |> ignore

        try
            let ids = List<int64>()
            for item in items do
                Helper.insertInner this.IncludeType item connection name transientConnection |> ids.Add

            connection.Execute "COMMIT;" |> ignore
            ids
        with ex ->
            connection.Execute "ROLLBACK;" |> ignore
            reraise()
            
    /// <summary>
    /// Inserts or replaces a sequence of documents in a single transaction.
    /// </summary>
    /// <param name="items">The sequence of documents to insert or replace.</param>
    /// <returns>A list of IDs for the inserted or replaced documents.</returns>
    member this.InsertOrReplaceBatch (items: 'T seq) =
        if isNull items then raise (ArgumentNullException(nameof(items)))

        if this.InTransaction then
            use connection = connection.Get()

            let ids = List<int64>()
            for item in items do
                Helper.insertOrReplaceInner this.IncludeType item connection name this |> ids.Add
            ids
        else

        use connection = connection.Get()
        use _disabled = (unbox<IDisableDispose> connection).DisableDispose()
        let directConnection = Transitive connection
        let transientConnection = Collection(directConnection, name, connectionString, parentData)
        connection.Execute "BEGIN;" |> ignore
        
        try
            let ids = List<int64>()
            for item in items do
                Helper.insertOrReplaceInner this.IncludeType item connection name transientConnection |> ids.Add

            connection.Execute "COMMIT;" |> ignore
            ids
        with ex ->
            connection.Execute "ROLLBACK;" |> ignore
            reraise()

    /// <summary>
    /// Tries to find a document by its 64-bit integer ID.
    /// </summary>
    /// <param name="id">The ID of the document to find.</param>
    /// <returns>An option containing the document if found; otherwise, None.</returns>
    member this.TryGetById(id: int64) =
        use connection = connection.Get()
        match connection.QueryFirstOrDefault<DbObjectRow>($"SELECT Id, json_quote(Value) as ValueJSON FROM \"{name}\" WHERE Id = @id LIMIT 1", {|id = id|}) with
        | json when Object.ReferenceEquals(json, null) -> None
        | json -> fromSQLite<'T> json |> Some

    /// <summary>
    /// Finds a document by its 64-bit integer ID.
    /// </summary>
    /// <param name="id">The ID of the document to find.</param>
    /// <returns>The document with the specified ID.</returns>
    /// <exception cref="KeyNotFoundException">Thrown if no document with the specified ID is found.</exception>
    member this.GetById(id: int64) =
        match this.TryGetById id with
        | None -> raise (KeyNotFoundException (sprintf "There is no element with id '%i' inside collection '%s'" id name)) 
        | Some x -> x

    /// <summary>
    /// Deletes a document by its 64-bit integer ID.
    /// </summary>
    /// <param name="id">The ID of the document to delete.</param>
    /// <returns>The number of documents deleted (0 or 1).</returns>
    member this.DeleteById(id: int64) =
        use connection = connection.Get()
        connection.Execute ($"DELETE FROM \"{name}\" WHERE Id = @id", {|id = id|})

    /// <summary>
    /// Tries to find a document by its custom ID, as defined by the [Id] attribute on the document type.
    /// </summary>
    /// <typeparam name="'IdType">The type of the custom ID.</typeparam>
    /// <param name="id">The custom ID of the document to find.</param>
    /// <returns>An option containing the document if found; otherwise, None.</returns>
    member this.TryGetById<'IdType when 'IdType : equality>(id: 'IdType) : 'T option =
        // Use this function only if you know that 'IdType = 'R.
        let inline genericReinterpret (a: 'IdType) = Unsafe.As<'IdType, 'R>(&Unsafe.AsRef(&a))

        // If someone uses the wrong TryGetById method, or the compiler uses this.
        match typeof<'IdType> with
        // x.Equals is faster that F#'s structural comparison (=)
        | x when x.Equals typeof<int8> ->
            let id: int8 = genericReinterpret id
            this.TryGetById(int64 id)

        | x when x.Equals typeof<int16> ->
            let id: int16 = genericReinterpret id
            this.TryGetById(int64 id)

        | x when x.Equals typeof<int32> ->
            let id: int32 = genericReinterpret id
            this.TryGetById(int64 id)

        | x when x.Equals typeof<nativeint> ->
            let id: nativeint = genericReinterpret id
            this.TryGetById(int64 id)

        | x when x.Equals typeof<int64> ->
            let id: int64 = genericReinterpret id
            this.TryGetById(id)

        | x when x.Equals typeof<uint8> ->
            let id: uint8 = genericReinterpret id
            this.TryGetById(int64 id)

        | x when x.Equals typeof<uint16> ->
            let id: uint16 = genericReinterpret id
            this.TryGetById(int64 id)

        | x when x.Equals typeof<uint32> ->
            let id: uint32 = genericReinterpret id
            this.TryGetById(int64 id)

        | x when x.Equals typeof<unativeint> ->
            let id: unativeint = genericReinterpret id
            this.TryGetById(int64 id)

        | x when x.Equals typeof<uint64> ->
            let id: uint64 = genericReinterpret id
            this.TryGetById(int64 id)

        | _ ->

        let idProp = CustomTypeId<'T>.Value.Value.Property
        let filter, variables = QueryTranslator.translate name (ExpressionHelper.get(fun (x: 'T) -> x.Dyn<'IdType>(idProp) = id))
        use connection = connection.Get()
        match connection.QueryFirstOrDefault<DbObjectRow>($"SELECT Id, json_quote(Value) as ValueJSON FROM \"{name}\" WHERE {filter} LIMIT 1", variables) with
        | json when Object.ReferenceEquals(json, null) -> None
        | json -> fromSQLite<'T> json |> Some

    /// <summary>
    /// Finds a document by its custom ID, as defined by the [Id] attribute on the document type.
    /// </summary>
    /// <typeparam name="'IdType">The type of the custom ID.</typeparam>
    /// <param name="id">The custom ID of the document to find.</param>
    /// <returns>The document with the specified ID.</returns>
    /// <exception cref="KeyNotFoundException">Thrown if no document with the specified ID is found.</exception>
    member this.GetById<'IdType when 'IdType : equality>(id: 'IdType) : 'T =
        match this.TryGetById id with
        | None -> raise (KeyNotFoundException (sprintf "There is no element with id '%A' inside collection '%s'" id name)) 
        | Some x -> x

    /// <summary>
    /// Deletes a document by its custom ID, as defined by the [Id] attribute on the document type.
    /// </summary>
    /// <typeparam name="'IdType">The type of the custom ID.</typeparam>
    /// <param name="id">The custom ID of the document to delete.</param>
    /// <returns>The number of documents deleted.</returns>
    member this.DeleteById<'IdType when 'IdType : equality>(id: 'IdType) : int =
        // Use this function only if you know that 'IdType = 'R.
        let inline genericReinterpret (a: 'IdType) = Unsafe.As<'IdType, 'R>(&Unsafe.AsRef(&a))

        // If someone uses the wrong DeleteById method, or the compiler uses this.
        match typeof<'IdType> with
        // x.Equals is faster that F#'s structural comparison (=)
        | x when x.Equals typeof<int8> ->
            let id: int8 = genericReinterpret id
            this.DeleteById(int64 id)

        | x when x.Equals typeof<int16> ->
            let id: int16 = genericReinterpret id
            this.DeleteById(int64 id)

        | x when x.Equals typeof<int32> ->
            let id: int32 = genericReinterpret id
            this.DeleteById(int64 id)

        | x when x.Equals typeof<nativeint> ->
            let id: nativeint = genericReinterpret id
            this.DeleteById(int64 id)

        | x when x.Equals typeof<int64> ->
            let id: int64 = genericReinterpret id
            this.DeleteById(id)

        | x when x.Equals typeof<uint8> ->
            let id: uint8 = genericReinterpret id
            this.DeleteById(int64 id)

        | x when x.Equals typeof<uint16> ->
            let id: uint16 = genericReinterpret id
            this.DeleteById(int64 id)

        | x when x.Equals typeof<uint32> ->
            let id: uint32 = genericReinterpret id
            this.DeleteById(int64 id)

        | x when x.Equals typeof<unativeint> ->
            let id: unativeint = genericReinterpret id
            this.DeleteById(int64 id)

        | x when x.Equals typeof<uint64> ->
            let id: uint64 = genericReinterpret id
            this.DeleteById(int64 id)

        | _ ->

        let idProp = CustomTypeId<'T>.Value.Value.Property
        let filter, variables = QueryTranslator.translate name (ExpressionHelper.get(fun (x: 'T) -> x.Dyn<'IdType>(idProp) = id))
        use connection = connection.Get()
        connection.Execute ($"DELETE FROM \"{name}\" WHERE {filter}", variables)

    /// <summary>
    /// Updates an existing document in the collection. The document must have a valid ID.
    /// </summary>
    /// <param name="item">The document with updated values.</param>
    /// <exception cref="KeyNotFoundException">Thrown if no document with the item's ID is found.</exception>
    /// <exception cref="InvalidOperationException">Thrown if the document type does not have a recognizable ID property.</exception>
    member this.Update(item: 'T) =
        let filter, variables = 
            if HasTypeId<'T>.Value then
                let id = HasTypeId<'T>.Read item
                QueryTranslator.translate name (ExpressionHelper.get(fun (x: 'T) -> x.Dyn<int64>("Id") = id))
            else match CustomTypeId<'T>.Value with
                 | Some customId ->
                    let id = customId.GetId (item |> box)
                    let idProp = CustomTypeId<'T>.Value.Value.Property
                    QueryTranslator.translate name (ExpressionHelper.get(fun (x: 'T) -> x.Dyn<obj>(idProp) = id))
                 | None ->
                    raise (InvalidOperationException $"The item's type {typeof<'T>.Name} does not have a int64 Id property or a custom Id to use in the update process.")

        variables.["item"] <- if this.IncludeType then toTypedJson item else toJson item
        use connection = connection.Get()
        let count = connection.Execute ($"UPDATE \"{name}\" SET Value = jsonb(@item) WHERE " + filter, variables)
        if count <= 0 then
            raise (KeyNotFoundException "Could not Update any entities with specified Id.")
        ()

    /// <summary>
    /// Deletes all documents that match the specified filter.
    /// </summary>
    /// <param name="filter">A LINQ expression to filter the documents to delete.</param>
    /// <returns>The number of documents deleted.</returns>
    member this.DeleteMany(filter: Expression<Func<'T, bool>>) =
        if isNull filter then raise (ArgumentNullException(nameof(filter)))
        let filter, variables = QueryTranslator.translate name filter

        use connection = connection.Get()
        connection.Execute ($"DELETE FROM \"{name}\" WHERE " + filter, variables)

    /// <summary>
    /// Deletes the first document that matches the specified filter.
    /// </summary>
    /// <param name="filter">A LINQ expression to filter the document to delete.</param>
    /// <returns>The number of documents deleted (0 or 1).</returns>
    member this.DeleteOne(filter: Expression<Func<'T, bool>>) =
        if isNull filter then raise (ArgumentNullException(nameof(filter)))
        let filter, variables = QueryTranslator.translate name filter

        use connection = connection.Get()
        connection.Execute ($"DELETE FROM \"{name}\" WHERE Id in (SELECT Id FROM \"{name}\" WHERE ({filter}) LIMIT 1)", variables)

    /// <summary>
    /// Replaces the content of all documents matching the filter with a new document.
    /// </summary>
    /// <param name="item">The new document content to use for replacement.</param>
    /// <param name="filter">A LINQ expression to filter the documents to replace.</param>
    /// <returns>The number of documents replaced.</returns>
    member this.ReplaceMany(item: 'T)(filter: Expression<Func<'T, bool>>) =
        if isNull filter then raise (ArgumentNullException(nameof(filter)))
        let filter, variables = QueryTranslator.translate name filter
        variables.["item"] <- if this.IncludeType then toTypedJson item else toJson item

        use connection = connection.Get()
        connection.Execute ($"UPDATE \"{name}\" SET Value = jsonb(@item) WHERE " + filter, variables)

    /// <summary>
    /// Replaces the content of the first document matching the filter with a new document.
    /// </summary>
    /// <param name="item">The new document content to use for replacement.</param>
    /// <param name="filter">A LINQ expression to filter the document to replace.</param>
    /// <returns>The number of documents replaced (0 or 1).</returns>
    member this.ReplaceOne(item: 'T)(filter: Expression<Func<'T, bool>>) =
        if isNull filter then raise (ArgumentNullException(nameof(filter)))
        let filter, variables = QueryTranslator.translate name filter
        variables.["item"] <- if this.IncludeType then toTypedJson item else toJson item

        use connection = connection.Get()
        connection.Execute ($"UPDATE \"{name}\" SET Value = jsonb(@item) WHERE Id in (SELECT Id FROM \"{name}\" WHERE ({filter}) LIMIT 1)", variables)

    /// <summary>
    /// Applies a set of transformations to update all documents that match the specified filter.
    /// </summary>
    /// <param name="transform">An array of expressions defining the updates to apply.</param>
    /// <param name="filter">A LINQ expression to filter the documents to update.</param>
    /// <returns>The number of documents updated.</returns>
    member this.UpdateMany(transform: Expression<System.Action<'T>> array)(filter: Expression<Func<'T, bool>>) =
        let transform = nullArgCheck (nameof transform) transform
        let filter = nullArgCheck (nameof filter) filter
        match transform.Length with
        | 0 -> 0 // If no transformations provided.
        | _ ->

        let variables = Dictionary<string, obj>()
        let fullSQL = StringBuilder()
        let inline append (txt: string) = ignore (fullSQL.Append txt)
        
        append "UPDATE \""
        append name
        append "\" SET Value = jsonb_set(Value, "

        for expression in transform do
            QueryTranslator.translateUpdateMode name expression fullSQL variables

        fullSQL.Remove(fullSQL.Length - 1, 1) |> ignore // Remove the ',' at the end.

        append ")  WHERE "
        QueryTranslator.translateQueryable name filter fullSQL variables

        let fullSQL = fullSQL.ToString()

        use connection = connection.Get()
        connection.Execute (fullSQL, variables)

    /// <summary>
    /// Ensures that a non-unique index exists for the specified expression. Creates the index if it does not exist.
    /// </summary>
    /// <typeparam name="'R">The type of the indexed property.</typeparam>
    /// <param name="expression">A LINQ expression that selects the property to be indexed.</param>
    member this.EnsureIndex<'R>(expression: Expression<System.Func<'T, 'R>>) =
        use connection = connection.Get()
        Helper.ensureIndex name connection expression

    /// <summary>
    /// Ensures that a unique index exists for the specified expression. Creates the index if it does not exist.
    /// </summary>
    /// <typeparam name="'R">The type of the indexed property.</typeparam>
    /// <param name="expression">A LINQ expression that selects the property to be indexed.</param>
    member this.EnsureUniqueAndIndex<'R>(expression: Expression<System.Func<'T, 'R>>) =
        use connection = connection.Get()
        Helper.ensureUniqueAndIndex name connection expression

    /// <summary>
    /// Drops an index if it exists for the specified expression.
    /// </summary>
    /// <typeparam name="'R">The type of the indexed property.</typeparam>
    /// <param name="expression">A LINQ expression that selects the property on which the index is defined.</param>
    member this.DropIndexIfExists<'R>(expression: Expression<System.Func<'T, 'R>>) =
        if isNull expression then raise (ArgumentNullException(nameof(expression)))
        let indexName, _whereSQL = Helper.getIndexWhereAndName<'T, 'R> name expression

        let indexSQL = $"DROP INDEX IF EXISTS \"{indexName}\""

        use connection = connection.Get()
        connection.Execute(indexSQL)
        
    /// <summary>
    /// Ensures that all indexes declared on the document type 'T using the [Indexed] attribute exist in the database.
    /// </summary>
    member this.EnsureAddedAttributeIndexes() =
        // Ignore the untyped collections.
        if not (typeof<JsonSerializator.JsonValue>.IsAssignableFrom typeof<'T>) then
            use conn = connection.Get()
            Helper.ensureDeclaredIndexesFields<'T> name conn

    override this.Equals(other) = 
        match other with
        | :? Collection<'T> as other ->
            (this :> IEquatable<Collection<'T>>).Equals other
        | other -> false

    override this.GetHashCode() = hash this

    interface IEquatable<Collection<'T>> with
        member this.Equals (other) =
            this.ConnectionString = other.ConnectionString && this.Name = other.Name


    interface IOrderedQueryable<'T>

    interface IQueryable<'T> with
        member this.Provider = this.SoloDBQueryable.Provider
        member this.Expression = this.SoloDBQueryable.Expression
        member this.ElementType = typeof<'T>

    interface IEnumerable<'T> with
        member this.GetEnumerator() =
            this.SoloDBQueryable.GetEnumerator()

    interface IEnumerable with
        member this.GetEnumerator() =
            (this :> IEnumerable<'T>).GetEnumerator() :> IEnumerator

    interface ISoloDBCollection<'T> with
        member this.InTransaction = this.InTransaction
        member this.IncludeType = this.IncludeType 
        member this.Name = this.Name

        member this.DropIndexIfExists(expression) = this.DropIndexIfExists(expression)
        member this.EnsureAddedAttributeIndexes() = this.EnsureAddedAttributeIndexes()
        member this.EnsureIndex(expression) = this.EnsureIndex(expression)
        member this.EnsureUniqueAndIndex(expression) = this.EnsureUniqueAndIndex(expression)
        member this.GetById(id) = this.GetById(id)
        member this.GetById(id: 'IdType) = this.GetById<'IdType>(id)
        member this.Insert(item) = this.Insert(item)
        member this.InsertBatch(items) = this.InsertBatch(items)
        member this.InsertOrReplace(item) = this.InsertOrReplace(item)
        member this.InsertOrReplaceBatch(items) = this.InsertOrReplaceBatch(items)
        member this.TryGetById(id) = this.TryGetById(id)
        member this.TryGetById(id: 'IdType) = this.TryGetById<'IdType>(id)
        member this.GetInternalConnection () = this.Connection.Get()
        member this.Delete(id: 'IdType) = this.DeleteById<'IdType>(id)
        member this.Delete(id) = this.DeleteById(id)
        member this.Update(item) = this.Update(item)
        member this.DeleteMany(filter) = this.DeleteMany(filter)
        member this.DeleteOne(filter) = this.DeleteOne(filter)
        member this.ReplaceMany(item,filter) = this.ReplaceMany(filter)(item)
        member this.ReplaceOne(item,filter) = this.ReplaceOne(filter)(item)
        member this.UpdateMany(filter, t) = this.UpdateMany(t)(filter)

/// <summary>
/// Represents a database context within an explicit transaction. All operations are part of the same transaction.
/// </summary>
/// <param name="connection">The transactional connection.</param>
type TransactionalSoloDB internal (connection: TransactionalConnection) =
    let connectionString = connection.ConnectionString

    /// <summary>
    /// Gets the underlying transactional connection.
    /// </summary>
    member val Connection = connection
    /// <summary>
    /// Gets a file system instance that operates within the current transaction.
    /// </summary>
    member val FileSystem = FileSystem (Connection.Transactional connection)

    member private this.InitializeCollection<'T> name =
        if not (Helper.existsCollection name connection) then 
            Helper.createTableInner<'T> name connection
            
        Collection<'T>(Transactional connection, name, connectionString, { ClearCacheFunction = ignore }) :> ISoloDBCollection<'T>

    /// <summary>
    /// Gets a collection of a specified type, using the type's name as the collection name. Creates the collection if it doesn't exist.
    /// </summary>
    /// <typeparam name="'T">The type of the documents in the collection.</typeparam>
    /// <returns>An <c>ISoloDBCollection<'T></c> instance.</returns>
    member this.GetCollection<'T>() =
        let name = Helper.collectionNameOf<'T>
        
        this.InitializeCollection<'T>(name)

    /// <summary>
    /// Gets a collection of a specified type with a custom name. Creates the collection if it doesn't exist.
    /// </summary>
    /// <typeparam name="'T">The type of the documents in the collection.</typeparam>
    /// <param name="name">The custom name for the collection.</param>
    /// <returns>An <c>ISoloDBCollection<'T></c> instance.</returns>
    member this.GetCollection<'T>(name) =       
        this.InitializeCollection<'T>(Helper.formatName name)

    /// <summary>
    /// Gets a collection that stores untyped JSON data.
    /// </summary>
    /// <param name="name">The name for the collection.</param>
    /// <returns>An <c>ISoloDBCollection<JsonValue></c> instance.</returns>
    member this.GetUntypedCollection(name: string) =
        let name = name |> Helper.formatName
        
        this.InitializeCollection<JsonSerializator.JsonValue>(name)

    /// <summary>
    /// Checks if a collection with the specified name exists.
    /// </summary>
    /// <param name="name">The name of the collection.</param>
    /// <returns>True if the collection exists, otherwise false.</returns>
    member this.CollectionExists name =
        Helper.existsCollection name connection

    /// <summary>
    /// Checks if a collection for the specified type exists.
    /// </summary>
    /// <typeparam name="'T">The document type.</typeparam>
    /// <returns>True if the collection exists, otherwise false.</returns>
    member this.CollectionExists<'T>() =
        let name = Helper.collectionNameOf<'T>
        Helper.existsCollection name connection

    /// <summary>
    /// Drops a collection if it exists.
    /// </summary>
    /// <param name="name">The name of the collection to drop.</param>
    /// <returns>True if the collection was dropped, false if it did not exist.</returns>
    member this.DropCollectionIfExists name =
        use _mutex = Helper.lockTable connectionString name

        if Helper.existsCollection name connection then
            Helper.dropCollection name connection
            true
        else false

    /// <summary>
    /// Drops a collection for the specified type if it exists.
    /// </summary>
    /// <typeparam name="'T">The document type.</typeparam>
    /// <returns>True if the collection was dropped, false if it did not exist.</returns>
    member this.DropCollectionIfExists<'T>() =
        let name = Helper.collectionNameOf<'T>
        this.DropCollectionIfExists name

    /// <summary>
    /// Drops a collection for the specified type.
    /// </summary>
    /// <typeparam name="'T">The document type.</typeparam>
    /// <exception cref="KeyNotFoundException">Thrown if the collection does not exist.</exception>
    member this.DropCollection<'T>() =
        if this.DropCollectionIfExists<'T>() = false then
            let name = Helper.collectionNameOf<'T>
            raise (KeyNotFoundException (sprintf "Collection %s does not exists." name))

    /// <summary>
    /// Drops a collection with the specified name.
    /// </summary>
    /// <param name="name">The name of the collection to drop.</param>
    /// <exception cref="KeyNotFoundException">Thrown if the collection does not exist.</exception>
    member this.DropCollection name =
        if this.DropCollectionIfExists name = false then
            raise (KeyNotFoundException (sprintf "Collection %s does not exists." name))

    /// <summary>
    /// Lists the names of all existing collections in the database.
    /// </summary>
    /// <returns>A sequence of collection names.</returns>
    member this.ListCollectionNames() =
        connection.Query<string>("SELECT Name FROM SoloDBCollections")

[<Struct>]
/// <summary>
/// Represents the storage location of a SoloDB database.
/// </summary>
type internal SoloDBLocation =
| /// <summary>The database is stored in a physical file.</summary>
  File of filePath: string
| /// <summary>The database is stored in-memory.</summary>
  Memory of name: string

/// <summary>
/// The main database class, representing a single SQLite database file or in-memory instance.
/// Provides access to collections and file system storage.
/// </summary>
type SoloDB private (connectionManager: ConnectionManager, connectionString: string, location: SoloDBLocation, config: SoloDBConfiguration) = 
    let mutable disposed = false

    /// <summary>
    /// Initializes a new instance of the SoloDB class.
    /// </summary>
    /// <param name="source">
    /// The path to the database file, or an in-memory identifier prefixed with "memory:".
    /// For example: "C:\data\mydb.db" or "memory:shared_db".
    /// </param>
    new(source: string) =
        let connectionString, location =
            if source.StartsWith("memory:", StringComparison.InvariantCultureIgnoreCase) then
                let memoryName = source.Substring "memory:".Length
                let memoryName = memoryName.Trim()
                sprintf "Data Source=%s;Mode=Memory;Cache=Shared;Pooling=False" memoryName, Memory memoryName
            else 
                let source = Path.GetFullPath source
                $"Data Source={source};Pooling=False", File source

        let usCultureInfo = CultureInfo.GetCultureInfo("en-us")
        let setup (connection: SqliteConnection) =          
            connection.CreateFunction("UNIXTIMESTAMP", Func<int64>(fun () -> DateTimeOffset.Now.ToUnixTimeMilliseconds()), false)
            connection.CreateFunction("SHA_HASH", Func<byte array, obj>(fun o -> Utils.shaHash o), true)
            connection.CreateFunction("TO_LOWER", Func<string, string>(_.ToLower(usCultureInfo)), true)
            connection.CreateFunction("TO_UPPER", Func<string, string>(_.ToUpper(usCultureInfo)), true)
            connection.CreateFunction("base64", Func<obj, obj>(Utils.sqlBase64), true) // https://www.sqlite.org/base64.html
            connection.Execute "PRAGMA recursive_triggers = ON;" |> ignore // This must be enabled on every connection separately.

        let defaultConfig: SoloDBConfiguration = { CachingEnabled = true }

        let manager = new ConnectionManager(connectionString, setup, defaultConfig)

        do
            use dbConnection = manager.Borrow()

            let schema = "
                PRAGMA journal_mode=wal;
                PRAGMA page_size=16384;
                PRAGMA recursive_triggers = ON;
                PRAGMA foreign_keys = on;

                BEGIN EXCLUSIVE;

                CREATE TABLE SoloDBCollections (Name TEXT NOT NULL) STRICT;
                                        

                CREATE TABLE SoloDBDirectoryHeader (
                    Id INTEGER PRIMARY KEY,
                    Name TEXT NOT NULL 
                        CHECK ((length(Name) != 0 OR ParentId IS NULL) 
                                AND (Name != \".\") 
                                AND (Name != \"..\") 
                                AND NOT Name GLOB \"*\\*\"
                                AND NOT Name GLOB \"*/*\"),
                    FullPath TEXT NOT NULL 
                        CHECK (FullPath != \"\" 
                                AND NOT FullPath GLOB \"*/./*\" 
                                AND NOT FullPath GLOB \"*/../*\"
                                AND NOT FullPath GLOB \"*\\*\"
                                -- Recursion limit check, see https://www.sqlite.org/limits.html
                                AND (LENGTH(FullPath) - LENGTH(REPLACE(FullPath, '/', '')) <= 900)),
                    ParentId INTEGER,
                    Created INTEGER NOT NULL DEFAULT (UNIXTIMESTAMP()),
                    Modified INTEGER NOT NULL DEFAULT (UNIXTIMESTAMP()),
                    FOREIGN KEY (ParentId) REFERENCES SoloDBDirectoryHeader(Id) ON DELETE CASCADE,
                    UNIQUE(ParentId, Name),
                    UNIQUE(FullPath)
                ) STRICT;

                CREATE TABLE SoloDBFileHeader (
                    Id INTEGER PRIMARY KEY,
                    Name TEXT NOT NULL 
                        CHECK (length(Name) != 0 
                                AND Name != \".\" 
                                AND Name != \"..\"
                                AND NOT Name GLOB \"*\\*\"
                                AND NOT Name GLOB \"*/*\"
                                ),
                    FullPath TEXT NOT NULL 
                        CHECK (FullPath != \"\" 
                                AND NOT FullPath GLOB \"*/./*\"
                                AND NOT FullPath GLOB \"*/../*\"
                                AND NOT FullPath GLOB \"*\\*\"),
                    DirectoryId INTEGER NOT NULL,
                    Created INTEGER NOT NULL DEFAULT (UNIXTIMESTAMP()),
                    Modified INTEGER NOT NULL DEFAULT (UNIXTIMESTAMP()),
                    Length INTEGER NOT NULL DEFAULT 0,
                    Hash BLOB NOT NULL DEFAULT (SHA_HASH('')),
                    FOREIGN KEY (DirectoryId) REFERENCES SoloDBDirectoryHeader(Id) ON DELETE CASCADE,
                    UNIQUE(DirectoryId, Name)
                ) STRICT;

                CREATE TABLE SoloDBFileChunk (
                    FileId INTEGER NOT NULL,
                    Number INTEGER NOT NULL,
                    Data BLOB NOT NULL,
                    FOREIGN KEY (FileId) REFERENCES SoloDBFileHeader(Id) ON DELETE CASCADE,
                    UNIQUE(FileId, Number) ON CONFLICT REPLACE
                ) STRICT;

                CREATE TABLE SoloDBFileMetadata (
                    Id INTEGER PRIMARY KEY,
                    FileId INTEGER NOT NULL,
                    Key TEXT NOT NULL,
                    Value TEXT NOT NULL,
                    UNIQUE(FileId, Key) ON CONFLICT REPLACE,
                    FOREIGN KEY (FileId) REFERENCES SoloDBFileHeader(Id) ON DELETE CASCADE
                ) STRICT;

                CREATE TABLE SoloDBDirectoryMetadata (
                    Id INTEGER PRIMARY KEY,
                    DirectoryId INTEGER NOT NULL,
                    Key TEXT NOT NULL,
                    Value TEXT NOT NULL,
                    UNIQUE(DirectoryId, Key) ON CONFLICT REPLACE,
                    FOREIGN KEY (DirectoryId) REFERENCES SoloDBDirectoryHeader(Id) ON DELETE CASCADE
                ) STRICT;



                -- Trigger to update the Modified column on insert for SoloDBDirectoryHeader
                CREATE TRIGGER Insert_SoloDBDirectoryHeader
                AFTER INSERT ON SoloDBDirectoryHeader
                FOR EACH ROW
                BEGIN
                    -- Update parent directory's Modified timestamp, if ParentId is NULL then it will be a noop.
                    UPDATE SoloDBDirectoryHeader
                    SET Modified = NEW.Modified
                    WHERE Id = NEW.ParentId AND Modified < NEW.Modified;
                END;
                                        
                -- Trigger to update the Modified column on update for SoloDBDirectoryHeader
                CREATE TRIGGER Update_SoloDBDirectoryHeader
                AFTER UPDATE ON SoloDBDirectoryHeader
                FOR EACH ROW
                BEGIN
                    -- Update parent directory's Modified timestamp, if ParentId is NULL then it will be a noop.
                    UPDATE SoloDBDirectoryHeader
                    SET Modified = NEW.Modified
                    WHERE Id = NEW.ParentId AND Modified < NEW.Modified;
                END;
                                        
                -- Trigger to update the Modified column on insert for SoloDBFileHeader
                CREATE TRIGGER Insert_SoloDBFileHeader
                AFTER INSERT ON SoloDBFileHeader
                FOR EACH ROW
                BEGIN
                    -- Update parent directory's Modified timestamp
                    UPDATE SoloDBDirectoryHeader
                    SET Modified = NEW.Modified
                    WHERE Id = NEW.DirectoryId AND Modified < NEW.Modified;
                END;
                
                -- Trigger to update the Modified column on update for SoloDBFileHeader
                CREATE TRIGGER Update_SoloDBFileHeader
                AFTER UPDATE OF Hash ON SoloDBFileHeader
                FOR EACH ROW
                BEGIN
                    UPDATE SoloDBFileHeader
                    SET Modified = UNIXTIMESTAMP()
                    WHERE Id = NEW.Id AND Modified < UNIXTIMESTAMP();
                    
                    -- Update parent directory's Modified timestamp
                    UPDATE SoloDBDirectoryHeader
                    SET Modified = UNIXTIMESTAMP()
                    WHERE Id = NEW.DirectoryId AND Modified < UNIXTIMESTAMP();
                END;

                CREATE INDEX SoloDBCollectionsNameIndex ON SoloDBCollections(Name);

                CREATE INDEX SoloDBDirectoryHeaderParentIdIndex ON SoloDBDirectoryHeader(ParentId);
                CREATE UNIQUE INDEX SoloDBDirectoryHeaderFullPathIndex ON SoloDBDirectoryHeader(FullPath);
                CREATE UNIQUE INDEX SoloDBFileHeaderFullPathIndex ON SoloDBFileHeader(FullPath);
                CREATE UNIQUE INDEX SoloDBDirectoryMetadataDirectoryIdAndKey ON SoloDBDirectoryMetadata(DirectoryId, Key);

                CREATE INDEX SoloDBFileHeaderDirectoryIdIndex ON SoloDBFileHeader(DirectoryId);
                CREATE UNIQUE INDEX SoloDBFileChunkFileIdAndNumberIndex ON SoloDBFileChunk(FileId, Number);
                CREATE UNIQUE INDEX SoloDBFileMetadataFileIdAndKey ON SoloDBFileMetadata(FileId, Key);
                CREATE INDEX SoloDBFileHashIndex ON SoloDBFileHeader(Hash);

                INSERT INTO SoloDBDirectoryHeader (Name, ParentId, FullPath)
                SELECT '', NULL, '/'
                WHERE NOT EXISTS (
                    SELECT 1
                    FROM SoloDBDirectoryHeader
                    WHERE ParentId IS NULL AND Name = ''
                );

                PRAGMA user_version = 1;
                COMMIT TRANSACTION;
                "
            
            let mutable dbSchemaVersion = dbConnection.QueryFirst<int> "PRAGMA user_version;";
            let currentSupportedSchemaVersion = 2; // Added a check so it will not open future version of the schema.

            if dbSchemaVersion > currentSupportedSchemaVersion then
                raise (NotSupportedException $"The schema version of the current DB is {dbSchemaVersion}, but the current version is {currentSupportedSchemaVersion}. This check can be mistaken if the user modified the 'PRAGMA user_version;' pragma, in which the version is stored.")

            if dbSchemaVersion = 0 then
                use command = new SqliteCommand(schema, dbConnection.Inner)
                // command.Prepare() // It does not work if the referenced tables are not created yet.
                ignore (command.ExecuteNonQuery())
                dbSchemaVersion <- dbConnection.QueryFirst<int> "PRAGMA user_version;"
                if dbSchemaVersion = 0 then
                    failwithf "Failure to create the schema."

            if dbSchemaVersion = 1 then
                use command = new SqliteCommand("
                    BEGIN EXCLUSIVE;

                    DROP INDEX SoloDBFileHashIndex;

                    -- The update will be handled inside filestream's code.
                    DROP TRIGGER Update_SoloDBFileHeader;
                    ALTER TABLE SoloDBFileHeader DROP COLUMN \"Hash\";

                    PRAGMA user_version = 2;
                    PRAGMA foreign_keys = on;

                    COMMIT TRANSACTION;
                ", dbConnection.Inner)
                command.Prepare()
                ignore (command.ExecuteNonQuery())
                dbSchemaVersion <- dbConnection.QueryFirst<int> "PRAGMA user_version;"
                if dbSchemaVersion = 1 then
                    failwithf "Failure to create the schema."


            // https://www.sqlite.org/pragma.html#pragma_optimize
            let _rez = dbConnection.Execute("PRAGMA optimize=0x10002;")
            ()
        
        

        new SoloDB(manager, connectionString, location, defaultConfig)

    /// <summary>
    /// Gets the underlying connection manager for the database.
    /// </summary>
    member this.Connection = connectionManager
    /// <summary>
    /// Gets the connection string used by this database instance.
    /// </summary>
    member this.ConnectionString = connectionString
    /// <summary>
    /// Gets the storage location (File or Memory) of the database.
    /// </summary>
    member val internal DataLocation = location
    /// <summary>
    /// Gets the configuration settings for this database instance.
    /// </summary>
    member val Config = config
    /// <summary>
    /// Gets an API for interacting with the virtual file system within the database.
    /// </summary>
    member val FileSystem = FileSystem (Connection.Pooled connectionManager)

    member private this.GetNewConnection() = connectionManager.Borrow()
        
    member private this.InitializeCollection<'T> (name: string) =    
        if disposed then raise (ObjectDisposedException(nameof(SoloDB)))
        if name.StartsWith "SoloDB" then raise (ArgumentException $"The SoloDB* prefix is forbidden in Collection names.")

        use _mutex = Helper.lockTable connectionString name // To prevent a race condition where the next if statment is true for 2 threads.

        use connection = connectionManager.Borrow()

        if not (Helper.existsCollection name connection) then 
            let withinTransaction = connection.IsWithinTransaction()
            if not withinTransaction then connection.Execute "BEGIN;" |> ignore
            try
                Helper.createTableInner<'T> name connection

                if not withinTransaction then connection.Execute "COMMIT;" |> ignore
            with ex ->
                if not withinTransaction then connection.Execute "ROLLBACK;" |> ignore
                reraise()

        Collection<'T>(Pooled connectionManager, name, connectionString, { ClearCacheFunction = this.ClearCache }) :> ISoloDBCollection<'T>

    /// <summary>
    /// Gets a collection of a specified type, using the type's name as the collection name. Creates the collection if it doesn't exist.
    /// </summary>
    /// <typeparam name="'T">The type of the documents in the collection.</typeparam>
    /// <returns>An <c>ISoloDBCollection<'T></c> instance.</returns>
    member this.GetCollection<'T>() =
        let name = Helper.collectionNameOf<'T>
        
        this.InitializeCollection<'T>(name)

    /// <summary>
    /// Gets a collection of a specified type with a custom name. Creates the collection if it doesn't exist.
    /// </summary>
    /// <typeparam name="'T">The type of the documents in the collection.</typeparam>
    /// <param name="name">The custom name for the collection.</param>
    /// <returns>An <c>ISoloDBCollection<'T></c> instance.</returns>
    member this.GetCollection<'T>(name) =       
        this.InitializeCollection<'T>(Helper.formatName name)

    /// <summary>
    /// Gets a collection that stores untyped JSON data.
    /// </summary>
    /// <param name="name">The name for the collection.</param>
    /// <returns>An <c>ISoloDBCollection<JsonValue></c> instance.</returns>
    member this.GetUntypedCollection(name: string) =
        let name = name |> Helper.formatName
        
        this.InitializeCollection<JsonSerializator.JsonValue>(name)

    /// <summary>
    /// Checks if a collection with the specified name exists.
    /// </summary>
    /// <param name="name">The name of the collection.</param>
    /// <returns>True if the collection exists, otherwise false.</returns>
    member this.CollectionExists name =
        use dbConnection = connectionManager.Borrow()
        Helper.existsCollection name dbConnection

    /// <summary>
    /// Checks if a collection for the specified type exists.
    /// </summary>
    /// <typeparam name="'T">The document type.</typeparam>
    /// <returns>True if the collection exists, otherwise false.</returns>
    member this.CollectionExists<'T>() =
        let name = Helper.collectionNameOf<'T>
        use dbConnection = connectionManager.Borrow()
        Helper.existsCollection name dbConnection

    /// <summary>
    /// Drops a collection if it exists.
    /// </summary>
    /// <param name="name">The name of the collection to drop.</param>
    /// <returns>True if the collection was dropped, false if it did not exist.</returns>
    member this.DropCollectionIfExists name =
        use mutex = Helper.lockTable connectionString name

        use connection = connectionManager.Borrow()

        if Helper.existsCollection name connection then
            let withinTransaction = connection.IsWithinTransaction()
            if not withinTransaction then connection.Execute "BEGIN;" |> ignore
            try
                Helper.dropCollection name connection

                if not withinTransaction then connection.Execute "COMMIT;" |> ignore
                true
            with ex ->
                if not withinTransaction then connection.Execute "ROLLBACK;" |> ignore
                reraise()
        else false

    /// <summary>
    /// Drops a collection for the specified type if it exists.
    /// </summary>
    /// <typeparam name="'T">The document type.</typeparam>
    /// <returns>True if the collection was dropped, false if it did not exist.</returns>
    member this.DropCollectionIfExists<'T>() =
        let name = Helper.collectionNameOf<'T>
        this.DropCollectionIfExists name

    /// <summary>
    /// Drops a collection for the specified type.
    /// </summary>
    /// <typeparam name="'T">The document type.</typeparam>
    /// <exception cref="KeyNotFoundException">Thrown if the collection does not exist.</exception>
    member this.DropCollection<'T>() =
        if this.DropCollectionIfExists<'T>() = false then
            let name = Helper.collectionNameOf<'T>
            raise (KeyNotFoundException (sprintf "Collection %s does not exists." name))

    /// <summary>
    /// Drops a collection with the specified name.
    /// </summary>
    /// <param name="name">The name of the collection to drop.</param>
    /// <exception cref="KeyNotFoundException">Thrown if the collection does not exist.</exception>
    member this.DropCollection name =
        if this.DropCollectionIfExists name = false then
            raise (KeyNotFoundException (sprintf "Collection %s does not exists." name))

    /// <summary>
    /// Lists the names of all existing collections in the database.
    /// </summary>
    /// <returns>A sequence of collection names.</returns>
    member this.ListCollectionNames() =
        use dbConnection = connectionManager.Borrow()
        dbConnection.Query<string>("SELECT Name FROM SoloDBCollections")

    /// <summary>
    /// Performs an online backup of this database to another SoloDB instance.
    /// </summary>
    /// <param name="otherDb">The destination database instance.</param>
    member this.BackupTo(otherDb: SoloDB) =
        use dbConnection = connectionManager.Borrow()
        use otherConnection = otherDb.GetNewConnection()
        dbConnection.Inner.BackupDatabase otherConnection.Inner

    /// <summary>
    /// Rebuilds the database file and writes it to a new location, defragmenting and optimizing it.
    /// </summary>
    /// <param name="location">The file path for the new, vacuumed database file.</param>
    /// <exception cref="InvalidOperationException">Thrown if the source database is in-memory.</exception>
    member this.VacuumTo(location: string) =
        match this.DataLocation with
        | Memory _ -> (raise << InvalidOperationException) "Cannot vacuum backup from or to memory."
        | other ->

        let location = Path.GetFullPath location
        if File.Exists location then File.Delete location

        use dbConnection = connectionManager.Borrow()
        dbConnection.Execute($"VACUUM INTO '{location}'")

    /// <summary>
    /// Rebuilds the database file in-place to defragment it and reclaim free space.
    /// </summary>
    /// <exception cref="InvalidOperationException">Thrown if the database is in-memory.</exception>
    member this.Vacuum() =
        match this.DataLocation with
        | Memory _ -> (raise << InvalidOperationException) "Cannot vacuum memory databases."
        | other ->

        use dbConnection = connectionManager.Borrow()
        dbConnection.Execute($"VACUUM;")

    /// <summary>
    /// Executes a series of database operations within a single atomic transaction.
    /// </summary>
    /// <param name="func">A function that takes a <c>TransactionalSoloDB</c> instance and returns a result.</param>
    /// <typeparam name="'R">The return type of the function.</typeparam>
    /// <returns>The result of the function.</returns>
    member this.WithTransaction<'R>(func: Func<TransactionalSoloDB, 'R>) : 'R =
        use connectionForTransaction = connectionManager.CreateForTransaction()
        try
            connectionForTransaction.Execute("BEGIN;") |> ignore
            let transactionalDb = new TransactionalSoloDB(connectionForTransaction)
            
            try
                let ret = func.Invoke transactionalDb
                connectionForTransaction.Execute "COMMIT;" |> ignore
                ret
            with _ex -> 
                connectionForTransaction.Execute "ROLLBACK;" |> ignore
                reraise()
        finally connectionForTransaction.DisposeReal(true)

    /// <summary>
    /// Executes a series of database operations within a single atomic transaction.
    /// </summary>
    /// <param name="func">An action that takes a <c>TransactionalSoloDB</c> instance.</param>
    member this.WithTransaction(func: Action<TransactionalSoloDB>) : unit =
        this.WithTransaction<unit>(fun tx -> func.Invoke tx)

    /// <summary>
    /// Asks the database engine to run analysis to optimize query plans.
    /// It is recommended to run this after making significant changes to data or indexes.
    /// </summary>
    member this.Optimize() =
        use dbConnection = connectionManager.Borrow()
        dbConnection.Execute "PRAGMA optimize;"

    /// <summary>
    /// Disables the in-memory cache of prepared SQL commands for all connections.
    /// </summary>
    member this.DisableCaching() =
        config.CachingEnabled <- false

    /// <summary>
    /// Clears the in-memory cache of prepared SQL commands across all connections without disabling it.
    /// </summary>
    member this.ClearCache() =
        connectionManager.All |> Seq.iter _.ClearCache()

    /// <summary>
    /// Enables the in-memory cache of prepared SQL commands for all connections. Caching is enabled by default.
    /// </summary>
    member this.EnableCaching() =
        config.CachingEnabled <- true

    /// <summary>
    /// Disposes the database instance, closing all connections and releasing resources.
    /// </summary>
    member this.Dispose() =
        disposed <- true
        (connectionManager :> IDisposable).Dispose()

    interface IDisposable with
        member this.Dispose() = this.Dispose()


    /// <summary>
    /// Analyzes the provided LINQ query and returns the query plan that SQLite would use to execute it.
    /// </summary>
    /// <remarks>Calling this function will clear the in-memory cache of prepared SQL commands.</remarks>
    /// <param name="query">The LINQ query to analyze.</param>
    /// <returns>A string describing the query plan.</returns>
    static member ExplainQueryPlan(query: IQueryable<'T>) =
        match query.Provider with
        | :? ISoloDBCollectionQueryProvider as p ->
            match p.AdditionalData with
            | :? SoloDBToCollectionData as data -> data.ClearCacheFunction()
            | _ -> ()
        | _ -> ()
        // This is a hack, I do not think that it is possible to add new IQueryable methods directly.
        query.Aggregate(QueryPlan.ExplainQueryPlanReference, (fun _a _b -> ""))

    /// <summary>
    /// Translates the provided LINQ query into its corresponding SQL statement.
    /// </summary>
    /// <param name="query">The LINQ query to translate.</param>
    /// <returns>The generated SQL string.</returns>
    static member GetSQL(query: IQueryable<'T>) =
        query.Aggregate(QueryPlan.GetGeneratedSQLReference, (fun _a _b -> ""))
